==> arg.q <==
\d .sys
/ ------------------------------------------------------------------------------------------------------------------------------
/ utilities for handling command-line arguments:
/ ------------------------------------------------------------------------------------------------------------------------------
/   split: return the break points for partial sums of y <= x (used to wrap text)
/    wrap: wrap string into sub-strings less than given width
/  getarg: convert command-line strings to same type as defaults, override where defined (replacement for .Q.def)
/ defread: read tab-delimited text file of defaults: name default choices help  (default & choices are strings to be executed)
/ defsave: save list/table of defaults to text file (default & choices are saved as executable strings of the q values)
/ deflist: take list of 4-element lists (name;default;choices;help) or one long list and convert to table
/ default: create table of defaults given file handle or array(s) of (name;default;choices;help) as one list, or n x 4
/          default may be scalar, list, or list of strings. choices may be empty, or list of allowable values
/          e.g. (`date; .z.D;    ();   "start date")
/               (`exch; "nq"; "amnqz"; "exchange(s), one of a,m,n,q,z")
/               (`exch; `n;    `n`q;   "pick one exchange symbol, n or q")
/   usage: print parameter defaults and descriptions to stderr
/     arg: parse command-line args, override defaults, check for -help, invalid parms
/          usage & arg take 3 arguments: 1-table of defaults (built by fn default), 2-brief overview, 3-help file or strings
/          arg[defaults;();()]
/          arg[defaults;"Overview..";`:helpfile]
/          arg[defaults;"Overview.."; helpstring(s)]
/ ------------------------------------------------------------------------------------------------------------------------------
split:{-2_(1+a bin a|x+-1_0,a:sums y)\[0]}
wrap:{" "sv'split[x;1+count each w]_w:" "vs y}
getarg:{x,(key[y]#x){$[s;raze;t<0h;first;::]$[s:10h=t:type x;t;type first x]$y}'y}
defread:{flip update`$name,get'[default],get'[choices]from(`$first r)!flip 1_r:"\t"vs'read0 x}
defsave:{x 0:"\t"0:@[y;`default`choices;-3!']}
deflist:{`name`default`choices`help!/:$[all 4=count'[x];x;0N 4#x]}
default:{$[98h=t:type x; x; -11h=t; @[defread;x;{'"Unable to read file\n",x}]; @[deflist;x;{'"Unable to parse defaults\n",x}]]}

usage:{
 x:default x; w:{raze wrap[85]'[` vs x]}; str:{x,$[0>t:type y;$[null y;"(null)";-3!y];$[count y;$[t=10;y;-3!y];"(empty vector)"]]};
 t:raze(raze flip each select name,w'[help]from x;
        select name,help:str["default: "]'[default]from x;
        select name,help:str["allowed: "]'[choices]from x where not 0=count'[choices]);
 m:("NAME";string .z.f),$[count y,:();("";"OVERVIEW";y);()],("";"OPTIONS");
 m,:2_.Q.S[2#100|system"c";0j]update{?[x=prev x;`;`$"-",'string x]}name,`$help from`name xasc t;
 -2` sv m,$[count z;("";"DESCRIPTION"),$[-11h=t:type z;@[read0;z;()];10h=abs t;enlist z,();z];()];}

arg:{
 if[`help in lower k:key c:.Q.opt .z.x; usage[x;y;z]; exit 1];
 if[count u:k except key a:exec name!default from x:default x; '"Undefined parameter: ",","sv string u];
 a:@[getarg[a]c;exec name from x where{$[11h=type x:raze over x;any x like":*";0b]}'[default];hsym];
 $[null c:first where not all'[(key[s]#a)in's:exec name!choices from x where not 0=count each choices]; a; 'string[c]," not in ",-3!s c]}

==> db.q <==
\d .sys
/ --------------------------------------------------------------------
/  utilities to create,update and load databases (splayed/partitioned)
/ --------------------------------------------------------------------
syminit:{$[()~key s:` sv x,y; s set`u#0#`; s]}
symset:{(` sv y,z)set get syminit[x]z}
symcopy:{(` sv y,z)set x z}
enumadd:{n:count x z; (` sv x,z)?y z; count[x z]-n}
remap:{$[i~k:til count i:x[z]?y z;();(`u#k)!i]}
enumtype:{$[t:type x;20h=t;all 20h=type'[x]]}
enumcols:{raze{(` sv x,)'[c where(enumtype x@)'[c:x`.d]]}'[dirs x]}
reset:{$[0=count d:-21!x; x; x,d`logicalBlockSize`algorithm`zipLevel]}
renumcol:{[s;m;z]$[all null[j]=null i:m j:"j"$v:value z; reset[z] set attr[v]#s!i; '"re-enumeration mapping error: ",1_string z]}

renum:{[a;z;p;s]   /a:db, z:staging dir, p-partition(e.g. date, null if none), s:sym name
 n:enumadd[a;z;s]; r:count m:remap[a;z;s];                    /merge staging syms w'target database
 msg(n;(neg n=1)_"new symbols");                              /indicate number of new symbols added
 msg(r;(neg r=1)_"remappings");                               /remappings if merged syms in different order
 if[r;                                                        /if remap required
  c@:idesc hcount'[c:enumcols $[null p;z;` sv z,`$string p]]; /list of enumerated cols in descending size
  renumcol[s;m]peach c; @[z;s;:;a s];                         /remap each col to use merged enumeration
  msg{(string x;neg[x=1]_"columns";"remapped")}count c];      /indicate count of re-enumerated columns
 r}                                                           /return flag indicating if remapping required

==> file.q <==
\d .sys
/ ----------------------------------------------------------------------------------------------
/ file system utilities
/ ----------------------------------------------------------------------------------------------
/     chmod: change file permissions, first arg is int(777), string("a+rx") or file handle to match, 2nd arg is handle
/        ls: error-trapped version of key -- prints error, returns empty array on unreadable dirs
/      tree: recurse through members of given tree symbol/file/dir handle
/  filetype: given file handle, return 0h-doesn't exist, 1h-file, 2h-dir
/  filetree: return list of file/dir handles given file/dir handle, else empty
/  filelist: return dictionary of files/dirs -> type in given directory(one level only,assume dir if error getting key)
/     files: return list of file handles given directory
/      dirs: return list of directories given directory
/        rm: remove each file & dir in tree via error-protected hdel call (slower than /bin/rm), return deleted list
/     rmdir: remove dir(s) via system call: /bin/rm -rf, return list of dir(s) not removed, displays any errors
/     mount: given file handle(s), returns mount point(s) as dir handles
/  redirect: redirect stdout,stderr to give file(s), null returns output to stdout/stderr
/ writeflag: return true if file/dir is writeable
/   modtime: return file modification time(s), given single symbol, returns single timestamp, else dictionary
/ ---------------------------------------------------------------------------------------------------------------------
chmod:{a:$[10h=t:type x; x; t in -5 -6 -7h; string x; t=-11h; "--reference=",1_string hsym x; '`type]; system" "sv(which`chmod;a;1_string hsym y)}
ls:@[key;;{-2 x;()}]
tree:{$[x~k:ls x;x;x,raze (.z.s` sv x,)'[k]]}
filetype:{$[-11h=t:type x; $[null x; 0h; x~hsym x; "h"$0 -11 11h?type ls x; '`type]; 11h=t; .z.s'[x]; '`type]}
filetree:{$[filetype x;tree x;()]}
filelist:{((0#`)!0#0h),$[2h=filetype x;(!/)flip{y,@[{$[x~ls x;1h;2h]};y:` sv x,y;2h]}[x]'[ls x];()]}
files:{where 1h=filelist x}
dirs:{where 2h=filelist x}
rm:{raze{@[hdel;x;{-2"Unable to delete ",x;()}]}each reverse filetree x}
rmdir:{"s"$@[system; " "sv(which`rm;"-rf"),s; {-2 z,": unable to remove ",", "sv y i:where not()~/:key'[x]; x i}[x]s:(1_string@)each x,:()]}
mount:{$[0>type x;first;::](hsym`$last@)each" "vs'1_system" "sv(which`df;"-P"),(1_string@)'[x,()]}
redirect:{{system string[x]," ",$[count y:(y like":*")_string y;y;"/dev/stdin"]}'[1 2;x];}
writeflag:{$[-11h=t:type x;not"B"$first system"([ -w ",((x like":*")_string x)," ]; echo $?)";t=11h;.z.s'[x];'`type]}

modtime:{
 if[not abs[t:type x]in 10 11h; '"modtime expects symbol(s) or single string"];
 c:which[`stat]," --format='%n\n%y' ";
 c,:{[t;x]$[-11h=t:type x; (x like":*")_string x; 11h=t; " "sv .z.s[t]'[x]; x]}[t]x;
 $[t=-11h;first;::]!/[@[flip"SP"$/:0N 2#system c;0;hsym']]}

/ ------------------------------------------------------------------------------------------------------------------
/   rename: q's internal rename x->y, if x is file, y can be existing file, if x is dir, y can only be empty dir
/ movetemp: if x exists, create temp dir in x's parent directory and move x into it
/     move: move x->y, return y  y must not already exist. return null if no x, treat null y as move to temp dir
/ movework: if working dir on different file system, move working partition to target file system in a temp dir
/ movepart: move partition z from working dir x -> y  leave any subdirs in y/z if not also in x/z
/ ------------------------------------------------------------------------------------------------------------------
rename:{system"r "," "sv(1_string hsym@)'[(x;y)]; y}
movetemp:{$[t:filetype x; rename[x;mktemp[first` vs x;t=2h]]; `]}
move:{$[filetype x; $[null y; movetemp x; t:filetype y; '" "sv(("";"File";"Directory")t;"exists:";1_string y); rename[x]y]; `]}
movework:{system" "sv enlist[which`mv],(1_string@)'[(` sv x,`$string z; w:tempdir first` vs y)]; w}

movepart:{                                                     /x-working dir, y-target, z-partition value
 if[m:not=/[mount x,y]; x:movework[x;y;z]];                    /move work dir -> temp dir on target file system
 t:type each k:key each d:{first` vs .Q.par[y;x;`]}[z]'[x,y];  /check partition in source & target
 if[not 11h=first t;'"Not a directory: ",1_string d 0];        /source partition must exist
 if[-11h=t@:1; hdel d 1; t:0h];                                /if target partition is file, erase
 if[0h=t; rename . d; if[m;rmdir x]; :last d];                 /if no target, simple rename
 {rename .` sv'x,'y}[d[1],w:tempdir x]'[inter/[k]];            /move target subdirs -> temp if in source
 {rename .` sv'x,'y}[d]'[k 0]; rmdir w,$[m;x;first d]; last d} /move source subdirs -> target, cleanup, return target partn

/ ----------------------------------------------------------------------------------------------
/ tempmask: mask for temp files, flag indicates if mask is for creation(true) or matching(false)
/   mktemp: call system utility to make temporary file or directory
/  tempdir: mktemp with bit flag true for directory, arg is dir whter temp subdir is created
/ tempfile: mktemp with bit flag false for temporary file, arg is dir where temp file created
/ ----------------------------------------------------------------------------------------------
tempmask:{"qtemp.",10#$[x;"X";"?"]}
mktemp:{hsym`$first system" "sv("TMPDIR=",s;.sys.which`mktemp;$[y;"-d";""];"-p";s:1_string`:/tmp^x;tempmask 1b)}
tempdir: mktemp[;1b]
tempfile:mktemp[;0b]

/ -------------------------------------------------------------------------------------------------
/  gzip: given file, creates arguments for default gzip level and blocksize
/ zinfo: return table of file and information returned by -21! recursing through directory level(s)
/  zpct: return compression percentage
/ -------------------------------------------------------------------------------------------------
gzip:(;17;2;6)

zinfo:{
 f:{$[count r:-21!x;r;`compressedLength`uncompressedLength`algorithm`logicalBlockSize`zipLevel!(hcount x;0i)where 2 3]};
 $[x~k:key x;first;::]{[f;x]$[x~k:key x; flip((1#`file)!1 1#x),f x; raze(.z.s[f]` sv x,)'[k]]}[f]x}

zpct:{100*1-exec sum[compressedLength]%sum uncompressedLength from zinfo x}

==> link.q <==
\d .sys
/ -------------------------------------------------------------------------------------------------
/  utilities to link partitioned databases together across common dates
/ -------------------------------------------------------------------------------------------------
/      hstr: convert file handle(s) to string(s), replacing leading colon with space
/  badlinks: system call to 'find' to find broken symbolic links in given directory
/   datedir: return table of dir w and corresponding dates subdirectories d
/   datemap: return a map of dates (as symbols) -> path in partitioned/segmented database
/     empty: return dictionary of partitioned table names -> empty prototypes
/  enumname: check table prototypes for enumerated columns (type=20h)
/  partinfo: dictionary of x:path, d:date->path, e:empty prototypes, s:enums, z:top-level objects
/   linkcmd: call ln -s in either form: src1 src2.. tgt or multiple src tgt pairs
/  linkname: return name w'prefix if not null prefix and name is not an enumeration or primary key
/  linkpath: if no table prefix, source tables all link to one target,else src-tgt pairs
/  linkbase: link enumeration vectors (no prefix) and tables present at base (not in date subdirs)
/  linkfill: check for missing tables in date subdirectories, write empty table instead of bad link
/  linkdate: create links for each date partition, checking for missing tables
/      link: link partitioned databases a & b, with prefix, to given target directory
/ linkmidas: link Midas database using given prefix, source & target dir
/ -------------------------------------------------------------------------------------------------
hstr:{$[-11h=type x; @[string x;0;:;" "]; @[;0;:;" "]'[string x]]}
badlinks:{hsym each `$system which[`find],hstr[x]," -type l -exec test ! -e {} \\; -print"}
datedir:{([]w:hsym`$readlink x;d:d where(d:key x)like"[0-9][0-9][0-9][0-9].[0-1][0-9].[0-3][0-9]")}
datemap:{exec d!w{` sv x,y}'d from $[`par.txt in key x; select[<d]from raze datedir'[hsym each`$read0` sv x,`par.txt]; datedir x]}
empty:{k!?[;();0b;()]'[x(0#.)'(k:key x),'`]}
enumname:{distinct raze{get key each where[20h=type each x]#x:flip x}'[x]}

partinfo:{
 if[0=count d:datemap x:hsym`$readlink x;'"no date partitions in",hstr x];
 s:enumname e:empty a:last d; `x`d`e`s`z!(x;d;e;s;key[x]except key[d],s)}

linkcmd:{f:{system x,y,z}which[`ln]," -s"; $[type y:hstr y;f[raze hstr x;y];f'[hstr x;y]];}
linkname:{[p;s;x] $[0>type x; $[null[p]|x in s; x; ` sv p,x]; .z.s[p;s]'[x]]}
linkpath:{[a;w;p;s]if[count s; linkcmd[(` sv a,)'[s]]$[null p;w;(` sv w,)'[` sv'p,'s]]]}
linkbase:{[x;w;p]linkpath[x`x;w]'[`,p;(x[`s]except key x`e;x`z)]}

linkfill:{[x;w;p;d]
 if[not count e:where not 11h=(type key@)'[a:t!(` sv x[`d][d],)'[t:key x`e]]; :a];
 .sys.msg("empty table on"; d; "for missing"; ", "sv string e);
 @[;`;:;]'[(` sv w,d,)'[linkname[p;x`s]e];x[`e]e]; e _ a}

linkdate:{[x;w;p;d] a:linkfill[x;w;p;d]; w:` sv w,d; linkcmd[a]$[null p;w;(` sv w,)'[linkname[p;x`s;key a]]]}

link:{[a;b;p;w]
 if[not 11h=type k:key w; '"target not a directory:",hstr w];
 if[not writeflag w; '"target directory not writable:",hstr w];
 if[count k; '"target directory not empty:",hstr w];
 .sys.msg"Checking partitions";
 x:update inter/[key each d]#/:d from partinfo'[(a;b)];
 if[not count d:key first x`d; '"no dates in common"];
 if[count a:inter/[x`s]; '"enumeration/key name clash: "," "sv string a];
 {{hdel x set 0b}'[(` sv x,)'[y,'`d]]}[w;d]; /create date dirs (quicker than mkdir call)
 .sys.msg("linking";count d;"dates,";first d;"-";last d;"in target";1_string w);
 linkbase'[x;w;p]; linkdate'[x;w;p]'[d];}

linkmidas:{[p;b;w]link[halq`midas`db;b;`,p;w]}

==> mail.q <==
\d .sys
/ ------------------------------------------------------------------------------------------------------------------
/  utilities to use mail from within q session
/ ------------------------------------------------------------------------------------------------------------------
/ attach: return 2 strings: newer form of "-a file.." and older: "uuencode a; uuencode .."
/         attach takes name of working directory and attachment(s)
/         attachments can be one or more triplets of (name;type;data), e.g. (`data.csv;"c"; ("sym,prc";"ibm;100.0"))
/         or (names;types;arrays), e.g. (`data.csv`data; "cx"; (("sym,prc";"ibm;100.0"); 1 2 3.5))
/   mail: send mail given a:address, c:cc, b:bcc, f:from string, s:subject string, m:message body, x:attachment(s)
/         address for to,cc,bcc can be symbol(s) or string (string can separate emails by comma, no spaces)
/         "from" string for senders name/description -- from & subject strings substitute backtick for any "'"
/ ------------------------------------------------------------------------------------------------------------------
attach:{[w;x]
 f:{[w;n;t;x]1_string(0:;1:;set)["cx"?t][` sv w,n;x]}[w]./:x:$[-11h=type first x;0N 3#x;flip x];
 (" "sv"-a ",/:f; raze" ; ",/:f{" "sv(x;y;string first z)}[which`uuencode]'x)}

mail:{[a;c;b;f;s;m;x]  /a:address, c:cc, b:bcc, f:from string, s:subject string, m:message body, x:attachment(s) (name;type;val);.. or (names;type;vals)
 qt:{"'",ssr[x,();"'";"`"],"'"};                                                          /fn to enclose string in single quotes (backtick for embedded)
 to:{$[count y; $[count x;x," ";""],$[10h=type y,:();y;","sv string y]; ""]};             /handle address(es) as single string, or symbol(s)
 try:@[{system "(",x," 2>/dev/null)";1b}; ; 0b];                                          /attempt system cmd, 1b if succeed, 0b failure
 z:" "sv(which`cat; 1_string tempfile[w:tempdir`]0:$[10h=abs type m;enlist m,();m,\:()]); /"cat tempfile"
 z:{(x," | ",y," ",z 0; "(",x,z[1],") | ",y)}[z;which`mail;attach[w]x];                   /2 forms: "cat f | mail -a .."  "(cat f; uuencode ..) | mail"
 z:z,\:" "sv(to["-c"]c; to["-b"]b; "-s"; $[count s;qt s;"(no subject)"]);                 /add: "-c cc -b bcc -s subj"
 z[0],:$[all count'[(f;u:getenv`USER)];" -r ",qt u," (",f,")";""],to[" ";a];              /newer: " -r 'user (description)' to"
 z[1],:to[" ";a],$[count f;" -- -F ",qt f;""];                                            /older passthru to sendmail: " to -- -F 'from name'"
 if[not try z 0; if[not try z 1; -2"ERROR: unable to send mail"]];                        /try newer mail call, then older form if failure
 @[system;" "sv(which`rm;"-rf";1_string w);{-2"Unable to erase temporary dir used for email:\n";x}];}

==> match.q <==
\d .sys

/ --------------------------------------------------------------------------------
/ utilities used in matching identifiers
/ --------------------------------------------------------------------------------
/ cusipdigit: given 8-char string, returns check digit character
/     cusip9: given 8-char string(s)/symbol(s), adds checkdigit, else unchanged
/    soundex: return soundex code given symbol(s)/string(s)
/ --------------------------------------------------------------------------------

suffix:{("sssss*";1#"\t")0:init`config`suffix.txt}

cusipdigit:{i:1 2 1 2 1 2 1 2*mod[;39]"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ*@#"?x; "01234567890"@10-mod[;10]sum(floor i%10)+mod[i;10]}
cusip9:{$[0h=t:type x; .z.s'[x]; 11h=type x; `$.z.s'[string x]; 8<>count q:$[s:-11h=type x;string x;x];x;$[s;`$;::]q,cusipdigit q]}

soundex:{d:"AEHIOUWYBFPVCGJKQSXZDTLMNR"!"00000000111122222222334556";
 f:{$[count y@:i:where not" "=y;x[i 0],3#(y where not "0"=y@:where 0b,1_differ y),"000";""]};
 `$$[type c:d x:upper$[type[x]in 0 10h;x;string x];f[x;c];f'[x;c]]}

==> q.q <==
{$[(e:getenv`QINIT)like""; -2"Environment variable: QINIT not defined";
   {@[system;x;{-2"Unable to load: ",x,"\n",y;}2_x]}'[("l ",1_string` sv first[` vs `$":",e],)'[x]]];}
 (`util.q;      /utilities
  `file.q;      /interacting with the file system
  `arg.q;       /command-line arguments to q scripts
  `db.q;        /utilities for database loads, enumeration, etc.
  `link.q;      /utilities for linking partitioned databases
  `mail.q;      /sending mail from q session, job completion, etc.
  `match.q;     /utilities for symbol suffixes, cusip check digit, etc used to match identifiers
  `wrds.q)      /sending commands via ssh to WRDS server,retrieving files etc.

==> util.q <==
\d .sys
/ --------------------------------------------------------------------------------------
/ system paths
/ --------------------------------------------------------------------------------------
/       halq: root path for databases, scripts
/       home: home directory as file handle with additional subdir(s) if supplied
/      qinit: return q script loaded via $QINIT as a file handle
/       init: returns the directory where initialization scripts reside
/     reinit: reload q script currently defined by env variable QINIT
/     define: define/load database(s) by symbol
/      which: dictionary of system binary name to full path (string)
/ scriptpath: given tag, return path, e.g. `match -> ${HALQ}/script/match/match.q
/ scriptload: given script path as file handle, load into q session
/     script: given tag, find and load corresponding script
/  halreport: load hal "report" scripts (requires changing working dir, then restoring)
/ --------------------------------------------------------------------------------------
halq:{
 if[0=count s:getenv`HALQ;s:"/home/AD.SEC.GOV/hal"];
 if[not 11h=type key w:hsym`$s; '"HALQ not set to a directory: ",s];
 $[any x~/:(();::); w; 11h=abs type x; ` sv w,x; '"empty arg or symbol(s) expected"]}

home:{
 if[not 11h=type key w:hsym`$$[count home:getenv`HOME; home; first system"echo ~"]; '"unable to get home directory"];
 $[any x~/:(();::); w; 11h=abs type x; ` sv w,x; '"empty arg or symbol(s) expected"]}

qinit:{$[count w:getenv`QINIT;hsym`$w;'"QINIT environment variable not defined"]}
init:{w:first` vs qinit[]; $[any x~/:(();::); w; 11h=abs type x; ` sv w,x; '"empty arg or symbol(s) expected"]}
reinit:{system"l ",1_string qinit[]}

define1:{![`.;();0b;1#x]; {last[` vs y]set get $[x;` sv y,`;y]}''[01b;{where x=y}[filelist y]'[1 2h]];}

define:{
 if[0<type x;.z.s each x;:(::)];
 if[not any x~/:a:`cat`crsp`midas`midas.old`otc`taq; '"expecting one of more symbols in `","`"sv string a];
 w:halq x,`db; $[x in`midas`midas.old;system"l ",1_string w; define1[x]w];}

which:raze{y!1_'string(` sv x,)each y,:()}./:raze flip each
 ((`:/bin;          `cat`chmod`cp`df`du`grep`gunzip`gzip`hostname`ln`mail`mkdir`mktemp`mv`readlink`rm`sleep`tty);
  (`:/usr/bin;      `curl`find`head`id`mkfifo`nohup`pigz`pwd`rsync`sftp`ssh`stat`taskset`test`unzip`uuencode`wget`zgrep`zip);
  (`:/usr/sbin;      1#`zdump);
  (halq`bin;         `getsheet`sshpass))

scriptpath:{halq`script,x,` sv x,`q}
scriptload:{system"l ",1_string x}
script:{$[11h=type x; .z.s'[x]; $[p~key p:scriptpath x;scriptload p;'"script not found: ",1_string p]];}

halreport:{
 if[0=count getenv`CONDA_PREFIX; `CONDA_PREFIX setenv 1_string halq`hal];
 w:first system which`pwd;
 system"cd ",1_string halq`hal`lib`q;
 q:3_string ` sv `:.,`hal`report,$[10h=t:type x:x,:();`$x; 11h=t;x; '"expecting string or symbols"];
 @[{system"l ",x}; q; {-2 "unable to load ",x,"\n",y}q];
 system"cd ",w}

/ ----------------------------------------------------------------------------
/ utilities for displaying recent dates & record counts for databases
/ ----------------------------------------------------------------------------
/ recent1: for identifier history, return date & active cols as of date
/ recent2: get number of active, added, inactive & changed in id history
/ recent3: count rows in tables over most recent 2 weeks in partitioned db
/  recent: given database tag, return table of row counts for most recent week
/ ----------------------------------------------------------------------------
recent1:{?[x;((<=;`date;z); ({x=(last;x)fby y};`date;y));0b;`date`b`a`k!(z;(=;`date;z);`active;y)]}

recent2:{
 a:$[any x~/:k:key m:`cat`crsp`otc`taq!`symbol`id`id`ticker; m x; '"recent: expects one of ","`"sv string k];
 t:(w:halq x,`db)` sv x,a;
 d:max $[c:x~`crsp;w[`crsp.date]`date;t`date]; d:{x where 1<x mod 7}d-reverse til 9; t:raze recent1[t;a]'[d];
 t:update sum'[not new in'prev new] from select active:sum a,new:k,inactive:sum b&not a,changed:sum b&a by date from t;
 $[c; (select prices:count i by date from w`crsp.dailyprice where date>d 0,not delist,not null price)lj t; t]}

recent3:{
 d:{x where 1<x mod 7}.z.D-1+reverse til 15; w:.Q.par[halq x,`db;;]'[d]'[key y];
 where[any each not null t]#t:select from`date xkey flip @[get[y]!@[{count y x}z;;0N]''[w];`date;:;d]}

recent:{
 if[not any x~/:a:`cat`crsp`midas`otc`taq; '"recent: expects one of ","`"sv string a];
 t:$[x~`midas; recent3[x;`trade_direct`bbo_cons`quotetimeline!`trades`quotes`quotetimeline;`ticker]div 1000000; recent2 x];
 xcol[`$": "sv string upper[x],`date] -5 sublist t}

/ -------------------------------------------------------------------------------------------
/  system utilities for messages, sleep, links, trap with backtrace, etc.
/ -------------------------------------------------------------------------------------------
/       str: strings from scalar or list, used for messages, e.g. `a`b -> "a b"
/      xstr: arg dictionary to string,
/            e.g. `date`file!(2022.12.14;`:/tmp/a.txt) -> "-date 2022.12.14 -file :/tmp/a.txt"
/      fstr: given file handle or symbol, convert to string with full path, returns any string unaltered
/      mstr: create string for msg function, convert atom elements and sets of strings
/       msg: timestamped message given string, strings or syms/numbers/dates
/    banner: surround timestamped message with lines (designed to mark beginning of log output for jobs)
/     comma: format numeric as string, "67,123"
/      perm: permutations given n distinct objects
/     sleep: sleep given number of seconds or derive seconds from time/minute/second argument
/   taskset: if empty arg, return cpu's bound to current task, resets if cpu range given
/  readlink: given file symbol/string, find full path of underlying file/dir
/      trap: run fn via .Q.trp, return 0 if no error, else print error & backtrace, return -1
/  getsheet: run bash script to extract worksheets form xlsx file to csv/psv/txt files
/ -------------------------------------------------------------------------------------------
str:{$[0h=t:type x; .z.s'[x]; 10h=t; x; -10h=t; 1#x; t within 1 20;" "sv string x; string x]}
xstr:{$[count x;" "sv raze flip("-",'string key x;str each get x);""]}
fstr:{$[10h=t:type x; x;  x like"/*"; string x; x like":/*"; 1_string x; 1_string` sv hsym[`$first system"pwd"],x]}
mstr:{$[10h=type s:str x;s;" "sv s]}
msg:{-2(" "sv string"dv"$'.z.P)," - ",mstr x;}
banner:{u:(100&22+count s:mstr x)#"_";-2(u;""); msg s; -2 u,"\n";}
comma:{$[0>t:type x; ((x<0)#"-"),","sv where[neg[n mod 3]rotate(n:count s)#100b]_s:string abs $[t in -5 -6 -7h;x;t in -8 -9h;"j"$x;'`domain]; .z.s each x]}
perm:{(x-1){raze(idesc each t=/:t:til 1+count first x)@\:0,'1+x}/1#0}
sleep:{system" "sv(which`sleep;string $[type[x]in -8 -9h;x;"i"$"v"$x])}
taskset:{$[b;first;::]system" "sv(which`taskset;"-pc";$[b:any x~/:(::;());"";x];string .z.i)}
readlink:{first system" "sv(which`readlink;"-e";(x like":*")_x:$[-10h=t:type x;x,();t=10h;x;string x])}
trap:{[f;x]a:1=count $[type g:get f;get g;g]1; .Q.trp[{[a;f;x]$[a;f x;f . x];0}[a]f; x; {-2"ERROR: ",x,"\nbacktrace:\n",.Q.sbt y;-1}]}

getsheet:{[x;w;p;d;s]
 if[not $[-11h=type x; x~key x:hsym x; 0b];                    '"xcsv: 1st arg must be the symbol handle of existing .xlsx file"];
 if[not $[-11h=type w; 11h=type key w:hsym w; 0b];             '"xcsv: 2nd arg must be the symbol handle of existing output directory"];
 p:$[-11h=t:type p; string p; t=10h; p; t=-10h; 1#p;           '"xcsv: 3rd arg must be a symbol/string prefix used to create csv file(s)"];
 d:$[0=count d; d; -10h=type d; d;                             '"xcsv: 4th arg must be empty or single character delimiter"];
 s:$[0=count s; (); 11h=t:type s,:(); s; t in 0 10h; (`$s),(); '"xcsv: 5th arg is empty or string(s)/symbol(s) of worksheets to convert"];
 c:" "sv(which`getsheet;1_string x;1_string w;p);
 if[count d; c,:" -delim ",$[d="\t"; "$'\\t'"; "'",d,"'"]];
 if[count s; c,:" -sheet "," " sv "'",'string[s],'"'"];
 system c}

/ -------------------------------------------------------------------------------------------
/     guid: unique session id
/     host: return table of host information system from configuration file
/ hostname: workaround for hosts (nyro-up-oitqaub09) without full domain name
/ hostopen: string piped into ssh task to connect back to invoking parent,
/           e.g. echo 'hopen`$":nyro-up-oitqaub09.sec.gov:5000:user:guid";'
/ taskauth: only allow user starting task from this session to connect back
/     task: start a worker process given host, options script, number of slaves and flags
/ -------------------------------------------------------------------------------------------
guid:@[get;`guid;{first -1?0Ng}]
host:{("jbjjss";1#"\t")0:init`config`host.txt}
hostname:$[.z.h like"*.*";.z.h;` sv .z.h,`sec.gov]
hostopen:{"echo 'hopen`$\"",sv[":";string(`;hostname;system"p";.z.u;guid)],"\";'"}
taskauth:{(y;z)~(x;string guid)} /connecting user:pass must match originating user & session id

task:{[h;s;f;a]                                      /h:host, s:threads, f:script, a:args(dict)
 if[p:not system"p"; system"p 0W"];                  /listen on next available port if none defined
 .z.pw:taskauth .z.u;                                /only this user, can connect back using session id
 c:hostopen[];                                       /set string to connect back from remote task
 c,:" | ",which[`ssh]," -q -o ControlMaster=no ";    /quiet and no multiplexing
 c,:string[h]," $Q ";                                /host name/ip and $Q for q comand
 c,:$[$[count f;not null f;0b];readlink f;""];       /add load script/db if supplied
 c,:" -q ",$[s;" -s ",string s;""]," ",xstr[a],"&";  /add quiet flag, any thread & script arg(s)
 system c; p}                                        /return flag indicating port was set

==> wrds.q <==
\d .sys

/ ------------------------------------------------------------
/ wrdshost: define host & user name from config file
/  wrdscmd: build command to login via sshpass & ssh/sftp
/     wrds: runs ssh command given as string on WRDS servers
/ wrdsfile: runs sftp commands given as string(s)
/ ------------------------------------------------------------
wrdshost:"@"sv(exec name!val from("s*";1#"\t")0:init`config`wrds.txt)`user`host
wrdscmd:{(which`sshpass;"-f";1_string home`.wrds;which x;wrdshost;y)}
wrds:{system" "sv wrdscmd[`ssh]x}
wrdstemp:{$[all 10h=type each x:$[type x;enlist x;x]; tempfile[`:/tmp]0:x; '"sftp command string(s) expected"]}
wrdsfile:{r:system" "sv wrdscmd[`sftp]"-q < ",1_string f:wrdstemp x; hdel f; r}
